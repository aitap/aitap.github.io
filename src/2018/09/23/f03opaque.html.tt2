[%~ PROCESS macros.tt2 ~%]
[%~ global.title = 'Wrapping C opaque pointers in Fortran 2003 in type-strict way' ~%]

"Opaque pointers":https://en.wikipedia.org/wiki/Opaque_pointer are a programming technique used to hide implememtation details. In C, you can declare that a @struct@ exists but don't tell the compiler anything else about it:

[% WRAPPER code, lang='c' %]
struct target;
struct target * new_target(void);
void shoot(struct target *);
[% END %]

At the cost of one more pointer access per function call you now have totally abstracted the inner details of the structure. You are now free to change them at will. The code that doesn't know the definition of the structure can only have pointers to objects of this incomplete type and distinguish between pointers of different types, but cannot peek inside:

[% WRAPPER code, lang='c' %]
struct foot;
struct foot * new_foot(void);

struct target * tgt = new_foot();
// warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
*tgt;
// error: dereferencing pointer to incomplete type ‘struct target’
[% END %]

Of course, reading the memory is not actually forbidden, as is type casting:

[% WRAPPER code, lang='c' %]
struct foot * f = new_foot();
char buf[256];
memcpy(buf, foot, 42); // the user still has to guess the size of the structure, though
// look ma, no warnings!
shoot((struct target*)foot);
[% END %]

If you find yourself questioning the use of such opaque pointers, have a look at @FILE*@-related functions in the standard C library. Depending on where you got it from, the actual @FILE@ may store just a file descriptor and a buffer, or a "dynamically allocated buffer that is pretending it's a file":http://pubs.opengroup.org/onlinepubs/9699919799/functions/open_memstream.html, or "something completely different":https://www.gnu.org/software/libc/manual/html_node/Streams-and-Cookies.html. And even if you only limit yourself to actual filesystems, by using @FILE*@ you stop caring whether the underlying file descriptor is a "HANDLE":https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea or an "int":http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html and how exactly should you do I/O on it.

So there is no surprise that "NLopt":https://nlopt.readthedocs.io/en/latest/ uses opaque pointers to hide the way it allocates and stores data:

[% WRAPPER code, lang='c' %]
struct nlopt_opt_s;
typedef struct nlopt_opt_s *nlopt_opt;
[% END %]

What if we want to call the library from Fortran? The "documentation":https://nlopt.readthedocs.io/en/latest/NLopt_Fortran_Reference/ states:

bq. The nlopt_opt type corresponds to integer*8. (Technically, we could use any type that is big enough to hold a pointer on all platforms; integer*8 is big enough for pointers on both 32-bit and 64-bit machines.)

NLopt supports very old programming language standards: if you omit a few algorithms from the library, you can build it with an ANSI C compiler and then call it from a FORTRAN 77 program. This is actually good (don't you hate it when a new app requires you to upgrade your libraries, your operating system, your computer, your spouse, and your cat?), but let's try to employ some techniques for writing cleaner and safer code brought to us by Fortran 90 (modules) and Fortran 2003 (C interoperability).

[% WRAPPER code, lang='f95' %]
type, bind(c) :: nlopt_opt
 private
 type(c_ptr) :: ptr
end type
[% END %]

"C standard, &sect;6.7.2.1":http://c0x.coding-guidelines.com/6.7.2.1.html#1423

bq. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa.
There may be unnamed padding within a structure object, but not at its beginning. 
